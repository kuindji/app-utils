import { BaseEventMap, DefaultEventMap, EventBusOptions } from "../eventBus";
import type { BaseHandler, ErrorListenerSignature, ErrorResponse } from "../lib/types";
export type { BaseEventMap, BaseHandler, ErrorListenerSignature, ErrorResponse, EventBusOptions, };
export declare function useEventBus<EventsMap extends BaseEventMap = DefaultEventMap>(eventBusOptions?: EventBusOptions<EventsMap>, allEventsListener?: BaseHandler, errorListener?: ErrorListenerSignature<any[]>): import("../lib/types").ApiType<import("../eventBus").EventBusDefinitionHelper<EventsMap>, {
    readonly addListener: <K extends import("../lib/types").KeyOf<import("../eventBus").GetEventsMap<EventsMap>>, H extends import("../eventBus").GetEventsMap<EventsMap>[K]["signature"]>(name: K, handler: H, options?: import("..").ListenerOptions) => void;
    readonly on: <K extends import("../lib/types").KeyOf<import("../eventBus").GetEventsMap<EventsMap>>, H extends import("../eventBus").GetEventsMap<EventsMap>[K]["signature"]>(name: K, handler: H, options?: import("..").ListenerOptions) => void;
    readonly listen: <K extends import("../lib/types").KeyOf<import("../eventBus").GetEventsMap<EventsMap>>, H extends import("../eventBus").GetEventsMap<EventsMap>[K]["signature"]>(name: K, handler: H, options?: import("..").ListenerOptions) => void;
    readonly subscribe: <K extends import("../lib/types").KeyOf<import("../eventBus").GetEventsMap<EventsMap>>, H extends import("../eventBus").GetEventsMap<EventsMap>[K]["signature"]>(name: K, handler: H, options?: import("..").ListenerOptions) => void;
    readonly once: <K extends import("../lib/types").KeyOf<import("../eventBus").GetEventsMap<EventsMap>>, H extends import("../eventBus").GetEventsMap<EventsMap>[K]["signature"]>(name: K, handler: H, options?: import("..").ListenerOptions) => void;
    readonly promise: <K extends import("../lib/types").KeyOf<import("../eventBus").GetEventsMap<EventsMap>>>(name: K, options?: import("..").ListenerOptions) => Promise<Parameters<EventsMap[K]>>;
    readonly removeListener: <K extends import("../lib/types").KeyOf<import("../eventBus").GetEventsMap<EventsMap>>, H extends import("../eventBus").GetEventsMap<EventsMap>[K]["signature"]>(name: K, handler: H, context?: object | null, tag?: string | null) => void;
    readonly un: <K extends import("../lib/types").KeyOf<import("../eventBus").GetEventsMap<EventsMap>>, H extends import("../eventBus").GetEventsMap<EventsMap>[K]["signature"]>(name: K, handler: H, context?: object | null, tag?: string | null) => void;
    readonly off: <K extends import("../lib/types").KeyOf<import("../eventBus").GetEventsMap<EventsMap>>, H extends import("../eventBus").GetEventsMap<EventsMap>[K]["signature"]>(name: K, handler: H, context?: object | null, tag?: string | null) => void;
    readonly remove: <K extends import("../lib/types").KeyOf<import("../eventBus").GetEventsMap<EventsMap>>, H extends import("../eventBus").GetEventsMap<EventsMap>[K]["signature"]>(name: K, handler: H, context?: object | null, tag?: string | null) => void;
    readonly unsubscribe: <K extends import("../lib/types").KeyOf<import("../eventBus").GetEventsMap<EventsMap>>, H extends import("../eventBus").GetEventsMap<EventsMap>[K]["signature"]>(name: K, handler: H, context?: object | null, tag?: string | null) => void;
    readonly trigger: <K extends import("../lib/types").KeyOf<import("../eventBus").GetEventsMap<EventsMap>>, A extends import("../eventBus").GetEventsMap<EventsMap>[K]["arguments"]>(name: K, ...args: A) => void;
    readonly emit: <K extends import("../lib/types").KeyOf<import("../eventBus").GetEventsMap<EventsMap>>, A extends import("../eventBus").GetEventsMap<EventsMap>[K]["arguments"]>(name: K, ...args: A) => void;
    readonly dispatch: <K extends import("../lib/types").KeyOf<import("../eventBus").GetEventsMap<EventsMap>>, A extends import("../eventBus").GetEventsMap<EventsMap>[K]["arguments"]>(name: K, ...args: A) => void;
    readonly get: <K extends import("../lib/types").KeyOf<import("../eventBus").GetEventsMap<EventsMap>>>(name: K) => { [key in import("../lib/types").KeyOf<EventsMap>]: import("../lib/types").ApiType<import("..").EventDefinitionHelper<EventsMap[key]>, {
        readonly addListener: (handler: EventsMap[key], listenerOptions?: import("..").ListenerOptions) => void;
        readonly on: (handler: EventsMap[key], listenerOptions?: import("..").ListenerOptions) => void;
        readonly listen: (handler: EventsMap[key], listenerOptions?: import("..").ListenerOptions) => void;
        readonly subscribe: (handler: EventsMap[key], listenerOptions?: import("..").ListenerOptions) => void;
        readonly removeListener: (handler: EventsMap[key], context?: object | null, tag?: string | null) => boolean;
        readonly un: (handler: EventsMap[key], context?: object | null, tag?: string | null) => boolean;
        readonly off: (handler: EventsMap[key], context?: object | null, tag?: string | null) => boolean;
        readonly remove: (handler: EventsMap[key], context?: object | null, tag?: string | null) => boolean;
        readonly unsubscribe: (handler: EventsMap[key], context?: object | null, tag?: string | null) => boolean;
        readonly trigger: (...args: Parameters<EventsMap[key]>) => void;
        readonly emit: (...args: Parameters<EventsMap[key]>) => void;
        readonly dispatch: (...args: Parameters<EventsMap[key]>) => void;
        readonly hasListener: (handler?: EventsMap[key] | null | undefined, context?: object | null, tag?: string | null) => boolean;
        readonly has: (handler?: EventsMap[key] | null | undefined, context?: object | null, tag?: string | null) => boolean;
        readonly removeAllListeners: (tag?: string) => void;
        readonly addErrorListener: (handler: ErrorListenerSignature<Parameters<EventsMap[key]>>, context?: object | null) => void;
        readonly removeErrorListener: (handler: ErrorListenerSignature<Parameters<EventsMap[key]>>, context?: object | null) => boolean;
        readonly suspend: (withQueue?: boolean) => void;
        readonly resume: () => void;
        readonly setOptions: (eventOptions: Pick<import("..").EventOptions<EventsMap[key]>, "async" | "limit" | "autoTrigger">) => void;
        readonly reset: () => void;
        readonly isSuspended: () => boolean;
        readonly isQueued: () => boolean;
        readonly withTags: <T extends (...args: any[]) => any>(tags: string[], callback: T) => ReturnType<T>;
        readonly promise: (options?: import("..").ListenerOptions) => Promise<Parameters<EventsMap[key]>>;
        readonly first: (...args: Parameters<EventsMap[key]>) => ReturnType<EventsMap[key]> | undefined;
        readonly resolveFirst: (...args: Parameters<EventsMap[key]>) => Promise<Awaited<ReturnType<EventsMap[key]>> | undefined>;
        readonly all: (...args: Parameters<EventsMap[key]>) => ReturnType<EventsMap[key]>[];
        readonly resolveAll: (...args: Parameters<EventsMap[key]>) => Promise<Awaited<ReturnType<EventsMap[key]>>[]>;
        readonly last: (...args: Parameters<EventsMap[key]>) => ReturnType<EventsMap[key]> | undefined;
        readonly resolveLast: (...args: Parameters<EventsMap[key]>) => Promise<Awaited<ReturnType<EventsMap[key]>> | undefined>;
        readonly merge: (...args: Parameters<EventsMap[key]>) => ReturnType<EventsMap[key]> | undefined;
        readonly resolveMerge: (...args: Parameters<EventsMap[key]>) => Promise<Awaited<ReturnType<EventsMap[key]>> | undefined>;
        readonly concat: (...args: Parameters<EventsMap[key]>) => (ReturnType<EventsMap[key]> extends infer T ? T extends ReturnType<EventsMap[key]> ? T extends (infer U)[] ? U : T : never : never)[];
        readonly resolveConcat: (...args: Parameters<EventsMap[key]>) => Promise<(Awaited<ReturnType<EventsMap[key]>> extends infer T ? T extends Awaited<ReturnType<EventsMap[key]>> ? T extends (infer U)[] ? U : T : never : never)[]>;
        readonly firstNonEmpty: (...args: Parameters<EventsMap[key]>) => ReturnType<EventsMap[key]> | undefined;
        readonly resolveFirstNonEmpty: (...args: Parameters<EventsMap[key]>) => Promise<Awaited<ReturnType<EventsMap[key]>> | undefined>;
        readonly untilTrue: (...args: Parameters<EventsMap[key]>) => void;
        readonly untilFalse: (...args: Parameters<EventsMap[key]>) => void;
        readonly pipe: (...args: Parameters<EventsMap[key]>) => ReturnType<EventsMap[key]> | undefined;
        readonly resolvePipe: (...args: Parameters<EventsMap[key]>) => Promise<Awaited<ReturnType<EventsMap[key]>> | undefined>;
        readonly raw: (...args: Parameters<EventsMap[key]>) => (ReturnType<EventsMap[key]> extends infer T ? T extends ReturnType<EventsMap[key]> ? T extends (infer U)[] ? U : T : never : never)[];
    }>; }[K];
    readonly add: (name: import("../lib/types").MapKey, options?: import("..").EventOptions<BaseHandler>) => void;
    readonly first: <K extends import("../lib/types").KeyOf<import("../eventBus").GetEventsMap<EventsMap>>, A extends import("../eventBus").GetEventsMap<EventsMap>[K]["arguments"]>(name: K, ...args: A) => ReturnType<EventsMap[K]> | undefined;
    readonly resolveFirst: <K extends import("../lib/types").KeyOf<import("../eventBus").GetEventsMap<EventsMap>>, A extends import("../eventBus").GetEventsMap<EventsMap>[K]["arguments"]>(name: K, ...args: A) => Promise<Awaited<ReturnType<EventsMap[K]>> | undefined>;
    readonly all: <K extends import("../lib/types").KeyOf<import("../eventBus").GetEventsMap<EventsMap>>, A extends import("../eventBus").GetEventsMap<EventsMap>[K]["arguments"]>(name: K, ...args: A) => ReturnType<EventsMap[K]>[];
    readonly resolveAll: <K extends import("../lib/types").KeyOf<import("../eventBus").GetEventsMap<EventsMap>>, A extends import("../eventBus").GetEventsMap<EventsMap>[K]["arguments"]>(name: K, ...args: A) => Promise<Awaited<ReturnType<EventsMap[K]>>[]>;
    readonly last: <K extends import("../lib/types").KeyOf<import("../eventBus").GetEventsMap<EventsMap>>, A extends import("../eventBus").GetEventsMap<EventsMap>[K]["arguments"]>(name: K, ...args: A) => ReturnType<EventsMap[K]> | undefined;
    readonly resolveLast: <K extends import("../lib/types").KeyOf<import("../eventBus").GetEventsMap<EventsMap>>, A extends import("../eventBus").GetEventsMap<EventsMap>[K]["arguments"]>(name: K, ...args: A) => Promise<Awaited<ReturnType<EventsMap[K]>> | undefined>;
    readonly merge: <K extends import("../lib/types").KeyOf<import("../eventBus").GetEventsMap<EventsMap>>, A extends import("../eventBus").GetEventsMap<EventsMap>[K]["arguments"]>(name: K, ...args: A) => ReturnType<EventsMap[K]> | undefined;
    readonly resolveMerge: <K extends import("../lib/types").KeyOf<import("../eventBus").GetEventsMap<EventsMap>>, A extends import("../eventBus").GetEventsMap<EventsMap>[K]["arguments"]>(name: K, ...args: A) => Promise<Awaited<ReturnType<EventsMap[K]>> | undefined>;
    readonly concat: <K extends import("../lib/types").KeyOf<import("../eventBus").GetEventsMap<EventsMap>>, A extends import("../eventBus").GetEventsMap<EventsMap>[K]["arguments"]>(name: K, ...args: A) => (ReturnType<EventsMap[K]> extends infer T ? T extends ReturnType<EventsMap[K]> ? T extends (infer U)[] ? U : T : never : never)[];
    readonly resolveConcat: <K extends import("../lib/types").KeyOf<import("../eventBus").GetEventsMap<EventsMap>>, A extends import("../eventBus").GetEventsMap<EventsMap>[K]["arguments"]>(name: K, ...args: A) => Promise<(Awaited<ReturnType<EventsMap[K]>> extends infer T ? T extends Awaited<ReturnType<EventsMap[K]>> ? T extends (infer U)[] ? U : T : never : never)[]>;
    readonly firstNonEmpty: <K extends import("../lib/types").KeyOf<import("../eventBus").GetEventsMap<EventsMap>>, A extends import("../eventBus").GetEventsMap<EventsMap>[K]["arguments"]>(name: K, ...args: A) => ReturnType<EventsMap[K]> | undefined;
    readonly resolveFirstNonEmpty: <K extends import("../lib/types").KeyOf<import("../eventBus").GetEventsMap<EventsMap>>, A extends import("../eventBus").GetEventsMap<EventsMap>[K]["arguments"]>(name: K, ...args: A) => Promise<Awaited<ReturnType<EventsMap[K]>> | undefined>;
    readonly untilTrue: <K extends import("../lib/types").KeyOf<import("../eventBus").GetEventsMap<EventsMap>>, A extends import("../eventBus").GetEventsMap<EventsMap>[K]["arguments"]>(name: K, ...args: A) => ReturnType<(...args: Parameters<EventsMap[K]>) => void>;
    readonly untilFalse: <K extends import("../lib/types").KeyOf<import("../eventBus").GetEventsMap<EventsMap>>, A extends import("../eventBus").GetEventsMap<EventsMap>[K]["arguments"]>(name: K, ...args: A) => ReturnType<(...args: Parameters<EventsMap[K]>) => void>;
    readonly pipe: <K extends import("../lib/types").KeyOf<import("../eventBus").GetEventsMap<EventsMap>>, A extends import("../eventBus").GetEventsMap<EventsMap>[K]["arguments"]>(name: K, ...args: A) => ReturnType<EventsMap[K]> | undefined;
    readonly resolvePipe: <K extends import("../lib/types").KeyOf<import("../eventBus").GetEventsMap<EventsMap>>, A extends import("../eventBus").GetEventsMap<EventsMap>[K]["arguments"]>(name: K, ...args: A) => Promise<Awaited<ReturnType<EventsMap[K]>> | undefined>;
    readonly raw: <K extends import("../lib/types").KeyOf<import("../eventBus").GetEventsMap<EventsMap>>, A extends import("../eventBus").GetEventsMap<EventsMap>[K]["arguments"]>(name: K, ...args: A) => (ReturnType<EventsMap[K]> extends infer T ? T extends ReturnType<EventsMap[K]> ? T extends (infer U)[] ? U : T : never : never)[];
    readonly withTags: <T extends (...args: any[]) => any>(tags: string[], callback: T) => ReturnType<T>;
    readonly intercept: (fn: (name: import("../lib/types").MapKey, args: any[], tags: string[] | null, returnType: import("../lib/types").TriggerReturnType | null) => boolean) => void;
    readonly stopIntercepting: () => void;
    readonly reset: () => void;
    readonly suspendAll: (withQueue?: boolean) => void;
    readonly resumeAll: () => void;
    readonly relay: ({ eventSource, remoteEventName, localEventName, proxyType, localEventNamePrefix, }: {
        eventSource: {
            on: (name: any, fn: (...args: any[]) => any, options?: import("..").ListenerOptions) => void;
            addAllEventsListener: (fn: (name: any, args: any[]) => any, options?: import("..").ListenerOptions) => void;
            un: (name: any, fn: (...args: any[]) => any, context?: object | null, tag?: string | null) => void;
            removeAllEventsListener: (fn: (name: any, args: any[]) => any, context?: object | null, tag?: string | null) => void;
        };
        remoteEventName: import("../lib/types").MapKey;
        localEventName?: any;
        proxyType?: import("../lib/types").ProxyType;
        localEventNamePrefix?: string | null;
    }) => void;
    readonly unrelay: ({ eventSource, remoteEventName, localEventName, proxyType, localEventNamePrefix, }: {
        eventSource: {
            on: (name: any, fn: (...args: any[]) => any, options?: import("..").ListenerOptions) => void;
            addAllEventsListener: (fn: (name: any, args: any[]) => any, options?: import("..").ListenerOptions) => void;
            un: (name: any, fn: (...args: any[]) => any, context?: object | null, tag?: string | null) => void;
            removeAllEventsListener: (fn: (name: any, args: any[]) => any, context?: object | null, tag?: string | null) => void;
        };
        remoteEventName: import("../lib/types").MapKey;
        localEventName?: any;
        proxyType?: import("../lib/types").ProxyType;
        localEventNamePrefix?: string | null;
    }) => void;
    readonly addEventSource: (eventSource: import("../eventBus").EventSource) => void;
    readonly removeEventSource: (eventSource: import("../eventBus").EventSource | import("../lib/types").MapKey) => void;
    readonly addAllEventsListener: (handler: (name: import("../lib/types").MapKey, args: any[], tags: string[] | null) => void, listenerOptions?: import("..").ListenerOptions) => void;
    readonly removeAllEventsListener: (handler: (name: import("../lib/types").MapKey, args: any[], tags: string[] | null) => void, context?: object | null, tag?: string | null) => boolean;
    readonly addErrorListener: (handler: ErrorListenerSignature<any[]>, listenerOptions?: import("..").ListenerOptions) => void;
    readonly removeErrorListener: (handler: ErrorListenerSignature<any[]>, context?: object | null, tag?: string | null) => boolean;
}>;
