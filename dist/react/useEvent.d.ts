import { type EventOptions } from "../event";
import type { BaseHandler, ErrorListenerSignature, ErrorResponse } from "../lib/types";
export type { BaseHandler, ErrorListenerSignature, ErrorResponse, EventOptions, };
export declare function useEvent<Listener extends BaseHandler = BaseHandler, ErrorListener extends ErrorListenerSignature<Parameters<Listener>> = ErrorListenerSignature<Parameters<Listener>>>(eventOptions?: EventOptions<Listener>, listener?: Listener | null, errorListener?: ErrorListener | null): import("../lib/types").ApiType<import("../event").EventDefinitionHelper<Listener>, {
    readonly addListener: (handler: Listener, listenerOptions?: import("../event").ListenerOptions) => void;
    readonly on: (handler: Listener, listenerOptions?: import("../event").ListenerOptions) => void;
    readonly listen: (handler: Listener, listenerOptions?: import("../event").ListenerOptions) => void;
    readonly subscribe: (handler: Listener, listenerOptions?: import("../event").ListenerOptions) => void;
    readonly removeListener: (handler: Listener, context?: object | null, tag?: string | null) => boolean;
    readonly un: (handler: Listener, context?: object | null, tag?: string | null) => boolean;
    readonly off: (handler: Listener, context?: object | null, tag?: string | null) => boolean;
    readonly remove: (handler: Listener, context?: object | null, tag?: string | null) => boolean;
    readonly unsubscribe: (handler: Listener, context?: object | null, tag?: string | null) => boolean;
    readonly trigger: (...args: Parameters<Listener>) => void;
    readonly emit: (...args: Parameters<Listener>) => void;
    readonly dispatch: (...args: Parameters<Listener>) => void;
    readonly hasListener: (handler?: Listener | null | undefined, context?: object | null, tag?: string | null) => boolean;
    readonly has: (handler?: Listener | null | undefined, context?: object | null, tag?: string | null) => boolean;
    readonly removeAllListeners: (tag?: string) => void;
    readonly addErrorListener: (handler: ErrorListenerSignature<Parameters<Listener>>, context?: object | null) => void;
    readonly removeErrorListener: (handler: ErrorListenerSignature<Parameters<Listener>>, context?: object | null) => boolean;
    readonly suspend: (withQueue?: boolean) => void;
    readonly resume: () => void;
    readonly setOptions: (eventOptions: Pick<EventOptions<Listener>, "async" | "limit" | "autoTrigger">) => void;
    readonly reset: () => void;
    readonly isSuspended: () => boolean;
    readonly isQueued: () => boolean;
    readonly withTags: <T extends (...args: any[]) => any>(tags: string[], callback: T) => ReturnType<T>;
    readonly promise: (options?: import("../event").ListenerOptions) => Promise<Parameters<Listener>>;
    readonly first: (...args: Parameters<Listener>) => ReturnType<Listener> | undefined;
    readonly resolveFirst: (...args: Parameters<Listener>) => Promise<Awaited<ReturnType<Listener>> | undefined>;
    readonly all: (...args: Parameters<Listener>) => ReturnType<Listener>[];
    readonly resolveAll: (...args: Parameters<Listener>) => Promise<Awaited<ReturnType<Listener>>[]>;
    readonly last: (...args: Parameters<Listener>) => ReturnType<Listener> | undefined;
    readonly resolveLast: (...args: Parameters<Listener>) => Promise<Awaited<ReturnType<Listener>> | undefined>;
    readonly merge: (...args: Parameters<Listener>) => ReturnType<Listener> | undefined;
    readonly resolveMerge: (...args: Parameters<Listener>) => Promise<Awaited<ReturnType<Listener>> | undefined>;
    readonly concat: (...args: Parameters<Listener>) => (ReturnType<Listener> extends infer T ? T extends ReturnType<Listener> ? T extends (infer U)[] ? U : T : never : never)[];
    readonly resolveConcat: (...args: Parameters<Listener>) => Promise<(Awaited<ReturnType<Listener>> extends infer T ? T extends Awaited<ReturnType<Listener>> ? T extends (infer U)[] ? U : T : never : never)[]>;
    readonly firstNonEmpty: (...args: Parameters<Listener>) => ReturnType<Listener> | undefined;
    readonly resolveFirstNonEmpty: (...args: Parameters<Listener>) => Promise<Awaited<ReturnType<Listener>> | undefined>;
    readonly untilTrue: (...args: Parameters<Listener>) => void;
    readonly untilFalse: (...args: Parameters<Listener>) => void;
    readonly pipe: (...args: Parameters<Listener>) => ReturnType<Listener> | undefined;
    readonly resolvePipe: (...args: Parameters<Listener>) => Promise<Awaited<ReturnType<Listener>> | undefined>;
    readonly raw: (...args: Parameters<Listener>) => (ReturnType<Listener> extends infer T ? T extends ReturnType<Listener> ? T extends (infer U)[] ? U : T : never : never)[];
}>;
